#spring应用
> IOC和DI的区别： 
>> IOC:Inversion of Control 控制反转，是面向对象编程的一种设计原则，可以用来减低计算机代码之间的耦合度。  
>> DI:Dependency Injetion 依赖注入，是实现IOC最常见的方式，另外还有“依赖查找”（Dependency lookup）
>>> 注入方法有两种：构造方法注入，set方法注入，（接口注入已取消）


- **spring实现IOC的思路和方法：**   
    - spring实现IOC的思路:  
        - 提供一些配置信息用来描述类之间的依赖关系，然后由容器去解析这些配置信息，继而维护好对象之间的依赖关系，
        前提是对象之间的依赖关系必须在类中已经定义好了。A类有属性B类：A依赖于B
    - spring实现IOC的方法：  
        1. 应用程序中提供类，提供依赖关系（属性或者构造方法）
        2. 把需要交给容器管理的对象通过配置信息告诉容器（xml，annotation，javaconfig）
        3. 把各个类之间的依赖关系通过配置信息告诉容器
        
- **通过配置信息告诉容器的方法：**
    - **xml方式**
        - **注入方法两种**（主类利用ClassXmlApplicationContext类）
            - set方法注入（xml中bean配置property）  
                - 实现方法参考springApplication_xmldependencyInjetion包下的BClassService
            - 构造方法注入（xml中bean配置constrcutor-arg）  
                - 实现方法参考springApplication_xmldependencyInjetion包下的CClassService
    - **annotation方式**
        - 用xml使用注解形式的时候，通过一下代码开启注解  
            \<context:annotation-config></context:annotation-config> spring支持注解【这一行也可以不写，一样可以通】  
             <context:component-scan base-backage = "包名></context:component-scan> 指定扫描的包
    - **javaconfig方式告诉容器**（主类利用AnnotationConfigApplicationContext类）
        - 实现方式查看IocConfig.class，通过在类上加@Configuration@ComponentScan("指定扫描的包路径")

- **自动装配**
    - xml中的自动装配 default-autowire = "byType"
        - 如果同时设置了一个父类的两个子类的bean，spring不知道加载哪个，会报错
        - xml中可以指定哪一个bean启动自动装配，直接在bean定义id的同一行写 autowire = “byType”
    - xml中的自动装配 default-autowire = "byName"
        - 上面byType的问题可以通过byName解决
        - 选择加载哪一个bean，这个Name是通过set类属性方法的名字来定的，例如在Service方法中设置了Dao属性dao，但是给定了set方法setXXX，
        那么加载的依赖是xml中id为XXX的相应类的bean
        - xml中可以指定哪一个bean启动自动装配，直接在bean定义id的同一行写 autowire = “byName”
     - @Autowired  
        - 默认使用byType自动装配，如果找不到会以byName方式(属性名)继续查找
     - @Resource(name="属性名")
         - 默认使用byName自动装配，但是和xml不一样，根据属性名来的，不是set方法名

- **bean的Scope作用范围**
    - singleton 默认的，单例
    - prototype 多例的，极少用
    - 注意：如果在单例中加入prototype的bean属性，prototype会失效，因为Ioc只加载bean一次
        - 如果想使用属性多例，怎么实现？   
            - 单例类implements ApplicationContextAware,添加ApplicationContext属性，重写setApplicationContext(ApplicationContext)方法，
            this.applicationContext = applicationContext（不推荐）   
            - 使用@lookup注解，具体百度，通过查找，就不用@autowired自动装配
      
- **包扫描的过滤条件**
    - excludeFilters 指定不扫描的文件
        - @ComponentScan(value = {"com.source.learn.ioc*","com.source.learn.*Callback"},  
            excludeFilters = @ComponentScan.Filter(Service.class)) 不扫描带有注解Service的类 默认过滤条件是注解类  
            或者excludeFilters = @ComponentScan.Filter(type = FilterType.REGEX, pattern = "com.*.IndexService")       

#spring源码说明
**源码阅读从此处进入：**  
执行结束，spring容器加载完成

`
AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class);
`

##IOC
- **实现BeanFactoryPostProcessor接口**
    -  重写postProcessBeanFactory方法：
        - 例如，在A类中添加@Component("A)使其注入容器，通过方法参数factory获取到关于A的BeanDefination对象，使用.setBeanClass()替换为B类，则容器中的A类已替换为B类  
        - beanDefinition(用来描述spring bean的)  
        - PS: 实现方式参照BeanA，BeanB，MyBeanFactoryPostProcessor

- **实现BeanPostProcessor接口**
    -  重写postProcessBeforeInitialization或者postProcessAfterInitialization
        -  不同于BeanFactoryPostProcessor，这个接口用于修改bean里面的内容，方法属性等...
##AOP
> 什么是面向切面? 
>> Aop ? ---- 编程需要实现的目标  
>> Spring Aop ? ---- 实现目标的手段  
>> aspectJ ? ---- 另一种实现目标的手段

* 什么是面向切面？  
  在传统的面向对象开发中，业务逻辑是自上而下的，但是会需要一些横切处理，比如日志记录，异常处理，权限验证，事务管理，效率检查等，但这些处理不影响整个主业务逻辑的执行，所以有时候要关注这些横切处理，即面向切面编程  

    * **aspect 切面：**
        advice所在的类称为切面，切面中描述了我们的业务逻辑将要增强到哪里，在什么时候增强    
    
    * **advice 通知：**  
        增强的逻辑，也可以理解为增强的位置【增强指，比如将日志功能这个切面加入到某个方法中，这个方法就增强了】
        
    * **join point 连接点：**  
        程序执行的一个点，在spring中就是一个方法
        
    * **pointcut 切点：**  
        某些连接点的集合
        
    * **introduction：**
    
    * **target object 目标对象：**  
        即原来的对象  
        
    * **aop proxy 代理对象：**  
        通过aop创建出来的代理对象（代理对象与原来对象中的方法，通过加入切面功能，方法增强了）  
          
    * **weaving 织入：**  
        将切面方法在原来对象的方法的基础上添加代理对象的方法  
        
* aspectJ support  
    * @PointCut("execuation(* com.....(..))")类似， 指定需要加入切面的方法  
      切点就是指定需要在什么方法里执行切面方法  
    * @Before("切面方法（带参数）") 类型，无参的直接()，指定在方法的时候执行切面方法  
    **advice方法不仅指定了切面方法执行的时机，方法体也是需要加入的业务逻辑**  


* 切点@Pointcut(......)表达式怎么写？  

    execution(modifiers-pattern? ret-type-pattern decalaring-type-pattern? name-pattern(param-pattern) throws-pattern?)  
    ? 表示当前项可以有也可以没有  
    modifiers-pattern ：方法的可见性，如public，protected  
    ret-type-pattern : 方法的返回值类型，如int，void等  
    declaring-type-pattern : 方法所在类的全路径名，如com.source.learn
    name-pattern : 方法名类型, 如method()  
    param-pattern : 方法的参数类型, 如java.lang.String,写..表示任意数量参数  
    throws-pattern : 方法抛出的异常类型，如java.lang.Exception
    * execution(public * *(..))所有公共方法都加入切面方法
    * within(com.类.*) 和execution维度不一样，指定在类上加了@within的类的方法  
    * args(指定参数类型) 如括号里为java.lang.String只指定方法参数为String的方法
    * @annotation("自定义注解的全类名") 只指定方法上加了自定义注解的方法
    * @Pointcut("this(XXX)") 表示指定方法返回值为XXX类的方法  
    
    ps: execution表达式可以加&&  ，支持多个
    